// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/aal/go/pkg/mod/github.com/hajimehoshi/ebiten/v2@v2.8.8/internal/glfw/monitor_unix.go:1:1
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2012 The glfw3-go Authors
// SPDX-FileCopyrightText: 2023 The Ebitengine Authors

//go:build darwin || freebsd || linux || netbsd || openbsd

package glfw; import _cgo_unsafe "unsafe"

// #define GLFW_INCLUDE_NONE
// #include "glfw3_unix.h"
//
// void goMonitorCB(void* monitor, int event);
//
// static GLFWmonitor *GetMonitorAtIndex(GLFWmonitor **monitors, int index) {
//   return monitors[index];
// }
//
// static GLFWvidmode GetVidmodeAtIndex(GLFWvidmode *vidmodes, int index) {
//   return vidmodes[index];
// }
//
// static void glfwSetMonitorCallbackCB() {
//   glfwSetMonitorCallback((GLFWmonitorfun)goMonitorCB);
// }
//
// static unsigned int GetGammaAtIndex(unsigned short *color, int i) {
//   return color[i];
// }
//
// static void SetGammaAtIndex(unsigned short *color, int i, unsigned short value) {
//   color[i] = value;
// }
import _ "unsafe"

import (
	"unsafe"
)

// Monitor represents a monitor.
type Monitor struct {
	data * /*line :41:8*/_Ctype_GLFWmonitor /*line :41:21*/
}

// GammaRamp describes the gamma ramp for a monitor.
type GammaRamp struct {
	Red   []uint16 // A slice of value describing the response of the red channel.
	Green []uint16 // A slice of value describing the response of the green channel.
	Blue  []uint16 // A slice of value describing the response of the blue channel.
}

var fMonitorHolder func(monitor *Monitor, event PeripheralEvent)

//export goMonitorCB
func goMonitorCB(monitor unsafe.Pointer, event  /*line :54:48*/_Ctype_int /*line :54:53*/) {
	fMonitorHolder(&Monitor{(* /*line :55:28*/_Ctype_GLFWmonitor /*line :55:41*/)(monitor)}, PeripheralEvent(event))
}

// GetMonitors returns a slice of handles for all currently connected monitors.
func GetMonitors() ([]*Monitor, error) {
	var length int

	mC := ( /*line :62:8*/_Cfunc_glfwGetMonitors /*line :62:24*/)((* /*line :62:28*/_Ctype_int /*line :62:33*/)(unsafe.Pointer(&length)))
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return nil, err
	}
	if mC == nil {
		return nil, nil
	}

	m := make([]*Monitor, length)

	for i := 0; i < length; i++ {
		m[i] = &Monitor{func() *_Ctype_struct_GLFWmonitor{ _cgo0 := /*line :73:39*/mC; var _cgo1 _Ctype_int = _Ctype_int /*line :73:48*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :73:52*/_Cfunc_GetMonitorAtIndex(_cgo0, _cgo1); }()}
	}

	return m, nil
}

// GetPrimaryMonitor returns the primary monitor. This is usually the monitor
// where elements like the Windows task bar or the OS X menu bar is located.
func GetPrimaryMonitor() (*Monitor, error) {
	m := ( /*line :82:7*/_Cfunc_glfwGetPrimaryMonitor /*line :82:29*/)()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return nil, err
	}
	if m == nil {
		return nil, nil
	}
	return &Monitor{m}, nil
}

// GetPos returns the position, in screen coordinates, of the upper-left
// corner of the monitor.
func (m *Monitor) GetPos() (x, y int, err error) {
	var xpos, ypos  /*line :95:17*/_Ctype_int /*line :95:22*/
	func() { _cgo0 := /*line :96:22*/m.data; var _cgo1 *_Ctype_int = /*line :96:30*/&xpos; var _cgo2 *_Ctype_int = /*line :96:37*/&ypos; _cgoCheckPointer(_cgo0, nil); /*line :96:43*/_Cfunc_glfwGetMonitorPos(_cgo0, _cgo1, _cgo2); }()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return 0, 0, err
	}
	return int(xpos), int(ypos), nil
}

// GetWorkarea returns the position, in screen coordinates, of the upper-left
// corner of the work area of the specified monitor along with the work area
// size in screen coordinates. The work area is defined as the area of the
// monitor not occluded by the operating system task bar where present. If no
// task bar exists then the work area is the monitor resolution in screen
// coordinates.
//
// This function must only be called from the main thread.
func (m *Monitor) GetWorkarea() (x, y, width, height int) {
	var cX, cY, cWidth, cHeight  /*line :112:30*/_Ctype_int /*line :112:35*/
	func() { _cgo0 := /*line :113:27*/m.data; var _cgo1 *_Ctype_int = /*line :113:35*/&cX; var _cgo2 *_Ctype_int = /*line :113:40*/&cY; var _cgo3 *_Ctype_int = /*line :113:45*/&cWidth; var _cgo4 *_Ctype_int = /*line :113:54*/&cHeight; _cgoCheckPointer(_cgo0, nil); /*line :113:63*/_Cfunc_glfwGetMonitorWorkarea(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	x, y, width, height = int(cX), int(cY), int(cWidth), int(cHeight)
	return
}

// GetContentScale function retrieves the content scale for the specified monitor.
// The content scale is the ratio between the current DPI and the platform's
// default DPI. If you scale all pixel dimensions by this scale then your content
// should appear at an appropriate size. This is especially important for text
// and any UI elements.
//
// This function must only be called from the main thread.
func (m *Monitor) GetContentScale() (float32, float32, error) {
	var x, y  /*line :126:11*/_Ctype_float /*line :126:18*/
	func() { _cgo0 := /*line :127:31*/m.data; var _cgo1 *_Ctype_float = /*line :127:39*/&x; var _cgo2 *_Ctype_float = /*line :127:43*/&y; _cgoCheckPointer(_cgo0, nil); /*line :127:46*/_Cfunc_glfwGetMonitorContentScale(_cgo0, _cgo1, _cgo2); }()
	return float32(x), float32(y), nil
}

// SetUserPointer sets the user-defined pointer of the monitor. The current value
// is retained until the monitor is disconnected. The initial value is nil.
//
// This function may be called from the monitor callback, even for a monitor
// that is being disconnected.
//
// This function may be called from any thread. Access is not synchronized.
func (m *Monitor) SetUserPointer(pointer unsafe.Pointer) {
	func() { _cgo0 := /*line :139:30*/m.data; _cgo1 := /*line :139:38*/pointer; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :139:46*/_Cfunc_glfwSetMonitorUserPointer(_cgo0, _cgo1); }()
}

// GetUserPointer returns the current value of the user-defined pointer of the
// monitor. The initial value is nil.
//
// This function may be called from the monitor callback, even for a monitor
// that is being disconnected.
//
// This function may be called from any thread. Access is not synchronized.
func (m *Monitor) GetUserPointer() unsafe.Pointer {
	return func() _cgo_unsafe.Pointer{ _cgo0 := /*line :150:37*/m.data; _cgoCheckPointer(_cgo0, nil); return /*line :150:44*/_Cfunc_glfwGetMonitorUserPointer(_cgo0); }()
}

// GetPhysicalSize returns the size, in millimetres, of the display area of the
// monitor.
//
// Note: Some operating systems do not provide accurate information, either
// because the monitor's EDID data is incorrect, or because the driver does not
// report it accurately.
func (m *Monitor) GetPhysicalSize() (width, height int, err error) {
	var wi, h  /*line :160:12*/_Ctype_int /*line :160:17*/
	func() { _cgo0 := /*line :161:31*/m.data; var _cgo1 *_Ctype_int = /*line :161:39*/&wi; var _cgo2 *_Ctype_int = /*line :161:44*/&h; _cgoCheckPointer(_cgo0, nil); /*line :161:47*/_Cfunc_glfwGetMonitorPhysicalSize(_cgo0, _cgo1, _cgo2); }()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return 0, 0, err
	}
	return int(wi), int(h), nil
}

// GetName returns a human-readable name of the monitor, encoded as UTF-8.
func (m *Monitor) GetName() (string, error) {
	mn := func() *_Ctype_char{ _cgo0 := /*line :170:29*/m.data; _cgoCheckPointer(_cgo0, nil); return /*line :170:36*/_Cfunc_glfwGetMonitorName(_cgo0); }()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return "", err
	}
	if mn == nil {
		return "", nil
	}
	return ( /*line :177:9*/_Cfunc_GoString /*line :177:18*/)(mn), nil
}

// MonitorCallback is the signature for monitor configuration callback
// functions.
type MonitorCallback func(monitor *Monitor, event PeripheralEvent)

// SetMonitorCallback sets the monitor configuration callback, or removes the
// currently set callback. This is called when a monitor is connected to or
// disconnected from the system.
//
// This function must only be called from the main thread.
func SetMonitorCallback(cbfun MonitorCallback) (MonitorCallback, error) {
	previous := fMonitorHolder
	fMonitorHolder = cbfun
	if cbfun == nil {
		( /*line :193:3*/_Cfunc_glfwSetMonitorCallback /*line :193:26*/)(nil)
	} else {
		( /*line :195:3*/_Cfunc_glfwSetMonitorCallbackCB /*line :195:28*/)()
	}
	return previous, nil
}

// GetVideoModes returns an array of all video modes supported by the monitor.
// The returned array is sorted in ascending order, first by color bit depth
// (the sum of all channel depths) and then by resolution area (the product of
// width and height).
func (m *Monitor) GetVideoModes() ([]*VidMode, error) {
	var length int

	vC := func() *_Ctype_struct_GLFWvidmode{ _cgo0 := /*line :207:28*/m.data; var _cgo1 *_Ctype_int = /*line :207:36*/(*_Ctype_int /*line :207:43*/)(unsafe.Pointer(&length)); _cgoCheckPointer(_cgo0, nil); return /*line :207:70*/_Cfunc_glfwGetVideoModes(_cgo0, _cgo1); }()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return nil, err
	}
	if vC == nil {
		return nil, nil
	}

	v := make([]*VidMode, length)

	for i := 0; i < length; i++ {
		t := ( /*line :218:8*/_Cfunc_GetVidmodeAtIndex /*line :218:26*/)(vC,  /*line :218:32*/_Ctype_int /*line :218:37*/(i))
		v[i] = &VidMode{int(t.width), int(t.height), int(t.redBits), int(t.greenBits), int(t.blueBits), int(t.refreshRate)}
	}

	return v, nil
}

// GetVideoMode returns the current video mode of the monitor. If you
// are using a full screen window, the return value will therefore depend on
// whether it is focused.
func (m *Monitor) GetVideoMode() (*VidMode, error) {
	t := func() *_Ctype_struct_GLFWvidmode{ _cgo0 := /*line :229:26*/m.data; _cgoCheckPointer(_cgo0, nil); return /*line :229:33*/_Cfunc_glfwGetVideoMode(_cgo0); }()
	if t == nil {
		return nil, nil
	}
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return nil, err
	}
	return &VidMode{int(t.width), int(t.height), int(t.redBits), int(t.greenBits), int(t.blueBits), int(t.refreshRate)}, nil
}

// SetGamma generates a 256-element gamma ramp from the specified exponent and then calls
// SetGamma with it.
func (m *Monitor) SetGamma(gamma float32) error {
	func() { _cgo0 := /*line :242:17*/m.data; var _cgo1 _Ctype_float = _Ctype_float /*line :242:32*/(gamma); _cgoCheckPointer(_cgo0, nil); /*line :242:40*/_Cfunc_glfwSetGamma(_cgo0, _cgo1); }()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return err
	}
	return nil
}

// GetGammaRamp retrieves the current gamma ramp of the monitor.
func (m *Monitor) GetGammaRamp() (*GammaRamp, error) {
	var ramp GammaRamp

	rampC := func() *_Ctype_struct_GLFWgammaramp{ _cgo0 := /*line :253:30*/m.data; _cgoCheckPointer(_cgo0, nil); return /*line :253:37*/_Cfunc_glfwGetGammaRamp(_cgo0); }()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return nil, err
	}
	if rampC == nil {
		return nil, nil
	}

	length := int(rampC.size)
	ramp.Red = make([]uint16, length)
	ramp.Green = make([]uint16, length)
	ramp.Blue = make([]uint16, length)

	for i := 0; i < length; i++ {
		ramp.Red[i] = uint16(( /*line :267:24*/_Cfunc_GetGammaAtIndex /*line :267:40*/)(rampC.red,  /*line :267:53*/_Ctype_int /*line :267:58*/(i)))
		ramp.Green[i] = uint16(( /*line :268:26*/_Cfunc_GetGammaAtIndex /*line :268:42*/)(rampC.green,  /*line :268:57*/_Ctype_int /*line :268:62*/(i)))
		ramp.Blue[i] = uint16(( /*line :269:25*/_Cfunc_GetGammaAtIndex /*line :269:41*/)(rampC.blue,  /*line :269:55*/_Ctype_int /*line :269:60*/(i)))
	}

	return &ramp, nil
}

// SetGammaRamp sets the current gamma ramp for the monitor.
func (m *Monitor) SetGammaRamp(ramp *GammaRamp) error {
	var rampC  /*line :277:12*/_Ctype_GLFWgammaramp /*line :277:27*/

	length := len(ramp.Red)

	for i := 0; i < length; i++ {
		( /*line :282:3*/_Cfunc_SetGammaAtIndex /*line :282:19*/)(rampC.red,  /*line :282:32*/_Ctype_int /*line :282:37*/(i),  /*line :282:42*/_Ctype_ushort /*line :282:50*/(ramp.Red[i]))
		( /*line :283:3*/_Cfunc_SetGammaAtIndex /*line :283:19*/)(rampC.green,  /*line :283:34*/_Ctype_int /*line :283:39*/(i),  /*line :283:44*/_Ctype_ushort /*line :283:52*/(ramp.Green[i]))
		( /*line :284:3*/_Cfunc_SetGammaAtIndex /*line :284:19*/)(rampC.blue,  /*line :284:33*/_Ctype_int /*line :284:38*/(i),  /*line :284:43*/_Ctype_ushort /*line :284:51*/(ramp.Blue[i]))
	}

	func() { _cgo0 := /*line :287:21*/m.data; _cgoBase1 := /*line :287:29*/&rampC; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); /*line :287:36*/_Cfunc_glfwSetGammaRamp(_cgo0, _cgo1); }()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return err
	}
	return nil
}
