// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/aal/go/pkg/mod/github.com/hajimehoshi/ebiten/v2@v2.8.8/internal/glfw/posix_thread_darwin.go:1:1
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2002-2006 Marcus Geelnard
// SPDX-FileCopyrightText: 2006-2017 Camilla LÃ¶wy <elmindreda@glfw.org>
// SPDX-FileCopyrightText: 2024 The Ebitengine Authors

package glfw

// #include "internal_unix.h"
import _ "unsafe"

import "unsafe"

// TODO: make these methods on GLFWtls like on windows
// TODO: use uintptr instead of unsafe.Pointer once matching C API is no longer needed

//export _glfwPlatformCreateTls
func _glfwPlatformCreateTls(tls * /*line :17:34*/_Ctype__GLFWtls /*line :17:44*/)  /*line :17:46*/_Ctype_GLFWbool /*line :17:56*/ {
	if tls.posix.allocated != False {
		panic("glfw: TLS must not be allocated")
	}
	if pthread_key_create(&tls.posix.key, 0) != 0 {
		errstr := ( /*line :22:13*/_Cfunc_CString /*line :22:21*/)("POSIX: Failed to create context TLS")
		defer func() func() { _cgo0 := /*line :23:16*/unsafe.Pointer(errstr); return func() { _cgoCheckPointer(_cgo0, nil); /*line :23:39*/_Cfunc_free(_cgo0); }}()()
		_glfwInputError(int32(PlatformError), errstr)
		return False
	}
	tls.posix.allocated = True
	return True
}

//export _glfwPlatformDestroyTls
func _glfwPlatformDestroyTls(tls * /*line :32:35*/_Ctype__GLFWtls /*line :32:45*/) {
	if tls.posix.allocated != 0 {
		pthread_key_delete(tls.posix.key)
	}
	*tls =  /*line :36:9*/_Ctype__GLFWtls /*line :36:19*/{}
}

//export _glfwPlatformGetTls
func _glfwPlatformGetTls(tls * /*line :40:31*/_Ctype__GLFWtls /*line :40:41*/) unsafe.Pointer {
	if tls.posix.allocated != True {
		panic("glfw: TLS must be allocated")
	}
	var p = pthread_getspecific(tls.posix.key)
	return *(*unsafe.Pointer)(unsafe.Pointer(&p)) // TODO: replace with uintptr
}

//export _glfwPlatformSetTls
func _glfwPlatformSetTls(tls * /*line :49:31*/_Ctype__GLFWtls /*line :49:41*/, value unsafe.Pointer) {
	if tls.posix.allocated != True {
		panic("glfw: TLS must be allocated")
	}
	pthread_setspecific(tls.posix.key, uintptr(value))
}

//export _glfwPlatformCreateMutex
func _glfwPlatformCreateMutex(mutex * /*line :57:38*/_Ctype__GLFWmutex /*line :57:50*/)  /*line :57:52*/_Ctype_GLFWbool /*line :57:62*/ {
	if mutex.posix.allocated != False {
		panic("glfw: mutex must not be allocated")
	}
	if pthread_mutex_init(&mutex.posix.handle, nil) != 0 {
		errstr := ( /*line :62:13*/_Cfunc_CString /*line :62:21*/)("POSIX: Failed to create mutex")
		defer func() func() { _cgo0 := /*line :63:16*/unsafe.Pointer(errstr); return func() { _cgoCheckPointer(_cgo0, nil); /*line :63:39*/_Cfunc_free(_cgo0); }}()()
		_glfwInputError(int32(PlatformError), errstr)
		return False
	}
	mutex.posix.allocated = True
	return True
}

//export _glfwPlatformDestroyMutex
func _glfwPlatformDestroyMutex(mutex * /*line :72:39*/_Ctype__GLFWmutex /*line :72:51*/) {
	if mutex.posix.allocated != 0 {
		pthread_mutex_destroy(&mutex.posix.handle)
	}
	*mutex =  /*line :76:11*/_Ctype__GLFWmutex /*line :76:23*/{}
}

//export _glfwPlatformLockMutex
func _glfwPlatformLockMutex(mutex * /*line :80:36*/_Ctype__GLFWmutex /*line :80:48*/) {
	if mutex.posix.allocated != True {
		panic("glfw: mutex must be allocated")
	}
	pthread_mutex_lock(&mutex.posix.handle)
}

//export _glfwPlatformUnlockMutex
func _glfwPlatformUnlockMutex(mutex * /*line :88:38*/_Ctype__GLFWmutex /*line :88:50*/) {
	if mutex.posix.allocated != True {
		panic("glfw: mutex must be allocated")
	}
	pthread_mutex_unlock(&mutex.posix.handle)
}
