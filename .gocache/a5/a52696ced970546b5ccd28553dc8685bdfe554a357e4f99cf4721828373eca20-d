// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/aal/go/pkg/mod/github.com/hajimehoshi/ebiten/v2@v2.8.8/internal/glfw/context_unix.go:1:1
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2012 The glfw3-go Authors
// SPDX-FileCopyrightText: 2023 The Ebitengine Authors

//go:build darwin || freebsd || linux || netbsd || openbsd

package glfw

//#include <stdlib.h>
//#define GLFW_INCLUDE_NONE
//#include "glfw3_unix.h"
import _ "unsafe"

import (
	"unsafe"
)

// MakeContextCurrent makes the context of the window current.
// Originally GLFW 3 passes a null pointer to detach the context.
// But since we're using receivers, DetachCurrentContext should
// be used instead.
func (w *Window) MakeContextCurrent() error {
	func() { _cgo0 := /*line :23:27*/w.data; _cgoCheckPointer(_cgo0, nil); /*line :23:34*/_Cfunc_glfwMakeContextCurrent(_cgo0); }()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return err
	}
	return nil
}

// DetachCurrentContext detaches the current context.
func DetachCurrentContext() error {
	( /*line :32:2*/_Cfunc_glfwMakeContextCurrent /*line :32:25*/)(nil)
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return err
	}
	return nil
}

// GetCurrentContext returns the window whose context is current.
func GetCurrentContext() (*Window, error) {
	w := ( /*line :41:7*/_Cfunc_glfwGetCurrentContext /*line :41:29*/)()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return nil, err
	}
	if w == nil {
		return nil, nil
	}
	return windows.get(w), nil
}

// SwapBuffers swaps the front and back buffers of the window. If the
// swap interval is greater than zero, the GPU driver waits the specified number
// of screen updates before swapping the buffers.
func (w *Window) SwapBuffers() error {
	func() { _cgo0 := /*line :55:20*/w.data; _cgoCheckPointer(_cgo0, nil); /*line :55:27*/_Cfunc_glfwSwapBuffers(_cgo0); }()
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return err
	}
	return nil
}

// SwapInterval sets the swap interval for the current context, i.e. the number
// of screen updates to wait before swapping the buffers of a window and
// returning from SwapBuffers. This is sometimes called
// 'vertical synchronization', 'vertical retrace synchronization' or 'vsync'.
//
// Contexts that support either of the WGL_EXT_swap_control_tear and
// GLX_EXT_swap_control_tear extensions also accept negative swap intervals,
// which allow the driver to swap even if a frame arrives a little bit late.
// You can check for the presence of these extensions using
// ExtensionSupported. For more information about swap tearing,
// see the extension specifications.
//
// Some GPU drivers do not honor the requested swap interval, either because of
// user settings that override the request or due to bugs in the driver.
func SwapInterval(interval int) error {
	( /*line :77:2*/_Cfunc_glfwSwapInterval /*line :77:19*/)( /*line :77:21*/_Ctype_int /*line :77:26*/(interval))
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return err
	}
	return nil
}

// ExtensionSupported reports whether the specified OpenGL or context creation
// API extension is supported by the current context. For example, on Windows
// both the OpenGL and WGL extension strings are checked.
//
// As this functions searches one or more extension strings on each call, it is
// recommended that you cache its results if it's going to be used frequently.
// The extension strings will not change during the lifetime of a context, so
// there is no danger in doing this.
func ExtensionSupported(extension string) (bool, error) {
	e := ( /*line :93:7*/_Cfunc_CString /*line :93:15*/)(extension)
	defer func() func() { _cgo0 := /*line :94:15*/unsafe.Pointer(e); return func() { _cgoCheckPointer(_cgo0, nil); /*line :94:33*/_Cfunc_free(_cgo0); }}()()
	ret := ( /*line :95:9*/_Cfunc_glfwExtensionSupported /*line :95:32*/)(e) != 0
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return false, err
	}
	return ret, nil
}

// GetProcAddress returns the address of the specified OpenGL or OpenGL ES core
// or extension function, if it is supported by the current context.
//
// A context must be current on the calling thread. Calling this function
// without a current context will cause a GLFW_NO_CURRENT_CONTEXT error.
//
// This function is used to provide GL proc resolving capabilities to an
// external C library.
func GetProcAddress(procname string) (unsafe.Pointer, error) {
	p := ( /*line :111:7*/_Cfunc_CString /*line :111:15*/)(procname)
	defer func() func() { _cgo0 := /*line :112:15*/unsafe.Pointer(p); return func() { _cgoCheckPointer(_cgo0, nil); /*line :112:33*/_Cfunc_free(_cgo0); }}()()
	ret := unsafe.Pointer(( /*line :113:24*/_Cfunc_glfwGetProcAddress /*line :113:43*/)(p))
	if err := fetchErrorIgnoringPlatformError(); err != nil {
		return nil, err
	}
	return ret, nil
}
